

자바스크립트의 스레드 (코드를 처리하는 일꾼)
자바스크립트는 싱글 스레드

a ... (3초)
b ... (2초)
c ... (5초)
d ... (30초)
e ... (8초)
main ... (5초) --- 53초

싱글 쓰레드인 자바스크립트의 특징은
현재 실행중인 태스크(기능, 구간, 섹션)가 종료되어야만 다음 태스크를 실행합니다.
이러한 특징 때문이 처리 시간이 지연되는 함수의 경우 굉장히 비효율적

따라서 자바스크립트는 이벤트 루프를 활용하여 기존의 태스크가 종료되지 않아도
다음 태스크를 곧바로 실행하는 방식인 비동기 처리방식을 도입 하였습니다.

동기 vs 비동기

동기는 코드를 순차적인 흐름으로 진행

----------------------------------------------------------------------------------------------------------

* 대표적인 비동기 함수
setTimeOut, setInterval, Promise

-----------------------------------------------------------------------------------------------------------

비동기 처리

비동기 처리 시간이 각각 다르기 때문에 결과를 예상할 수 없음
따라서 결과에 따라 다음 함수(비동기 이후 실행된 동기적이 함수)를 실행시키기 위하여 비동기를 동기적으로 처리

(1) call back

function 비동기 (callback) { ---> 비동기 함수

    setTimeOut(()=> {
        console.log("하나")
        callback(
            setTimeOut(()=>{
                console.log("둘")
            },1000)
        ) ------- > 비동기
    }, 1000)
    
} --------------------------------------------------> 콜백 지옥


function callback () { ---> 비동기 이후에 실행되어야 함
    setTimeOut(()=>{
        console.log("콜백"ㄴ)
    }, 1000)
}

---------------------------------------------------->

(2) promise
ES6에 도입, new 연산자와 함꼐 호출하고 인자로 콜백을 받습니다.
Promise는 호출 시에 바로 실행은 되지만 그 안에 resolve와 recject가 둘중 하나가 호출되기 전에는
then과 catch로 넘어가지 않습니다.

then --> promise 성공했을 때
catch --> promise 실패했을 때

비동기는 항상 성공 할까요

ex)

let num3
const result = new Promise((resolve, reject) => {
    비동기 함수 ...
    num=2
    resolve(num)


    resolve(성공 인자)
    reject(실패 인자)

}).then((인자) => {
    console.log(인자) // 성공 인자
    d(인자)
})
.catch((인자) => {
    console.log(인자) // 실패 인자
})


d(num)


(3) async await
    Promise로 비동기 처리를 한다고 하더라도, 콜백 지옥이 연상되는 것은 마찬가지
    비동기를 아예 동기적인 흐름 처리로 만들어버리자


    async를 통해 함수를 promise 변환
    await을 통해 해당 함수가 실행될 때까지 (promise가 resolve, rject) 대기 

    

    async function a(){
    }

    const a = async () =>  {
        try {

            const result = await new Promise(...) 
            console.log(result) --> return promise resolve

        } catech(err) {

            console.log(err) --> return promise reject
            // 예외 상황 처리문
        }
    }



-----------------------------------------------------------------------------------------------------------

백엔드랑 API로 데이터 통신

https://jsonplaceholder.typicode.com/

-----------------------------------------------------------------------------------------------------------

ajax?

    본래 의미는 Javascript를 비동기 통신, 클라이언트와 서버간의 데이터를 주고 받는 기술

        www.naver.com <--- html,css,js
                      ----> com/login <---- html, css, js

                      
-----------------------------------------------------------------------------------------------------------

* axios, fetch

    기존의 웹에선 비동기 요청을 보내기 위해 XML HTTP REQUEST 객체를 생성했어야함
    그러나 이런 XHR은 요청의 상태나 변경에 따라 개반자의 의도에 맞게 사용하기엔 적합하지않았음.
    따라서 이를 보안하기 위하여 HTTP 요청에 최적화되고 추상화도 되어있는 API들이 생겨나기 시작함.

    대표적으로 axios,fetch

    fetch
        ES6부터 자바스크립트의 빌트인 객체로 내장 되어있음, 안정성이 뛰어남
        Promise 기반으로 만들어져 코드 또한 간편함

        ex)
            fetch(url,option).then().catch()

    단 단점이 있다면 데이터 요청 및 응답 데이터 수신시 JSON를 데이터로 받아올 수 없기 때문에
    파싱작업이 필요함

    EX)

        responce.json()
        // string ->JSON

        JSON.stringfy()
        